import{RELAYER_DEFAULT_PROTOCOL as pe,RELAYER_EVENTS as L,EXPIRER_EVENTS as he,Store as K,Core as de}from"@walletconnect/core";import{pino as ge,getDefaultLoggerOptions as me,generateChildLogger as ue,getLoggerContext as we}from"@walletconnect/logger";import{IEngine as ye,ISignClient as Se}from"@walletconnect/types";import{TYPE_1 as Ie,createDelayedPromise as T,engineEvent as p,getInternalError as c,calcExpiry as _,isValidObject as k,getRequiredNamespacesFromNamespaces as Ee,getSdkError as R,handleDeeplinkRedirect as _e,isSessionCompatible as Re,isBrowser as Ne,hashMessage as z,isExpired as P,isValidParams as S,isUndefined as x,isValidRelays as fe,isValidRequiredNamespaces as ve,isValidNamespaces as Y,isConformingNamespaces as B,isValidString as D,isValidErrorReason as Pe,isValidRelay as qe,isValidController as Oe,isValidNamespacesChainId as W,isValidRequest as Ve,isValidNamespacesRequest as Te,isValidRequestExpiry as xe,isValidResponse as De,isValidEvent as Ce,isValidNamespacesEvent as Ae,parseExpirerTarget as Le,isValidId as be,getAppMetadata as Ge}from"@walletconnect/utils";import $e,{EventEmitter as Me}from"events";import{THIRTY_DAYS as Ue,SEVEN_DAYS as Q,FIVE_MINUTES as u,ONE_DAY as q,THIRTY_SECONDS as Z}from"@walletconnect/time";import{isJsonRpcResult as N,isJsonRpcError as f,getBigIntRpcId as Ke,formatJsonRpcRequest as ke,formatJsonRpcResult as ze,formatJsonRpcError as Ye,isJsonRpcRequest as je,isJsonRpcResponse as Je}from"@walletconnect/jsonrpc-utils";const j="wc",J=2,X="client",b=`${j}@${J}:${X}:`,G={name:X,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Xe={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire"},He={database:":memory:"},ee="WALLETCONNECT_DEEPLINK_CHOICE",Fe={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Be="history",We="0.3",se="proposal",Qe=Ue,te="Proposal expired",ie="session",C=Q,ne="engine",O={wc_sessionPropose:{req:{ttl:u,prompt:!0,tag:1100},res:{ttl:u,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u,prompt:!1,tag:1102},res:{ttl:u,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:q,prompt:!1,tag:1104},res:{ttl:q,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:q,prompt:!1,tag:1106},res:{ttl:q,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u,prompt:!0,tag:1108},res:{ttl:u,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u,prompt:!0,tag:1110},res:{ttl:u,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:q,prompt:!1,tag:1112},res:{ttl:q,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:Z,prompt:!1,tag:1114},res:{ttl:Z,prompt:!1,tag:1115}}},$={min:u,max:Q},re="request",oe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var Ze=Object.defineProperty,es=Object.defineProperties,ss=Object.getOwnPropertyDescriptors,ae=Object.getOwnPropertySymbols,ts=Object.prototype.hasOwnProperty,is=Object.prototype.propertyIsEnumerable,ce=(d,n,e)=>n in d?Ze(d,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):d[n]=e,w=(d,n)=>{for(var e in n||(n={}))ts.call(n,e)&&ce(d,e,n[e]);if(ae)for(var e of ae(n))is.call(n,e)&&ce(d,e,n[e]);return d},H=(d,n)=>es(d,ss(n));class ns extends ye{constructor(n){super(n),this.name=ne,this.events=new $e,this.initialized=!1,this.ignoredPayloadTypes=[Ie],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(O)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized();const s=H(w({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:o,relays:a}=s;let l=t,h,I=!1;if(l&&(I=this.client.core.pairing.pairings.get(l).active),!l||!I){const{topic:v,uri:y}=await this.client.core.pairing.create();l=v,h=y}const g=await this.client.core.crypto.generateKeyPair(),E=w({requiredNamespaces:i,optionalNamespaces:r,relays:a??[{protocol:pe}],proposer:{publicKey:g,metadata:this.client.metadata}},o&&{sessionProperties:o}),{reject:m,resolve:V,done:U}=T(u,te);if(this.events.once(p("session_connect"),async({error:v,session:y})=>{if(v)m(v);else if(y){y.self.publicKey=g;const F=H(w({},y),{requiredNamespaces:y.requiredNamespaces,optionalNamespaces:y.optionalNamespaces});await this.client.session.set(y.topic,F),await this.setExpiry(y.topic,y.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:y.peer.metadata}),V(F)}}),!l){const{message:v}=c("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(v)}const A=await this.sendRequest(l,"wc_sessionPropose",E),le=_(u);return await this.setProposal(A,w({id:A,expiry:le},E)),{uri:h,approval:U}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i,sessionProperties:r}=e,o=this.client.proposal.get(s);let{pairingTopic:a,proposer:l,requiredNamespaces:h,optionalNamespaces:I}=o;a=a||"",k(h)||(h=Ee(i,"approve()"));const g=await this.client.core.crypto.generateKeyPair(),E=l.publicKey,m=await this.client.core.crypto.generateSharedKey(g,E);a&&s&&(await this.client.core.pairing.updateMetadata({topic:a,metadata:l.metadata}),await this.sendResult(s,a,{relay:{protocol:t??"irn"},responderPublicKey:g}),await this.client.proposal.delete(s,R("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a}));const V=w({relay:{protocol:t??"irn"},namespaces:i,requiredNamespaces:h,optionalNamespaces:I,pairingTopic:a,controller:{publicKey:g,metadata:this.client.metadata},expiry:_(C)},r&&{sessionProperties:r});await this.client.core.relayer.subscribe(m),await this.sendRequest(m,"wc_sessionSettle",V);const U=H(w({},V),{topic:m,pairingTopic:a,acknowledged:!1,self:V.controller,peer:{publicKey:l.publicKey,metadata:l.metadata},controller:g});return await this.client.session.set(m,U),await this.setExpiry(m,_(C)),{topic:m,acknowledged:()=>new Promise(A=>setTimeout(()=>A(this.client.session.get(m)),500))}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,R("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:r,resolve:o,reject:a}=T();return this.events.once(p("session_update",i),({error:l})=>{l?a(l):o()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:r}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:i,resolve:r,reject:o}=T();return this.events.once(p("session_extend",t),({error:a})=>{a?o(a):r()}),await this.setExpiry(s,_(C)),{acknowledged:i}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:r}=e,o=await this.sendRequest(i,"wc_sessionRequest",{request:t,chainId:s},r),{done:a,resolve:l,reject:h}=T(r);this.events.once(p("session_request",o),({error:g,result:E})=>{g?h(g):l(E)}),this.client.events.emit("session_request_sent",{topic:i,request:t,chainId:s,id:o});const I=await this.client.core.storage.getItem(ee);return _e({id:o,topic:i,wcDeepLink:I}),await a()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;N(t)?await this.sendResult(i,s,t.result):f(t)&&await this.sendError(i,s,t.error),this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0})},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:i,resolve:r,reject:o}=T();this.events.once(p("session_ping",t),({error:a})=>{a?o(a):r()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:i})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=Ke().toString();let i;const r=o=>{o?.id.toString()===t&&(this.client.core.relayer.events.removeListener(L.message_ack,r),i())};await Promise.all([new Promise(o=>{i=o,this.client.core.relayer.on(L.message_ack,r)}),this.sendRequest(s,"wc_sessionDelete",R("USER_DISCONNECTED"),void 0,t)]),await this.deleteSession(s)}else await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>Re(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(i=>{var r,o;return((r=i.peerMetadata)==null?void 0:r.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}},this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),this.client.session.delete(e,R("USER_DISCONNECTED")),this.client.core.crypto.keychain.has(t.publicKey)&&await this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),s||this.client.core.expirer.del(e)},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,R("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=O.wc_sessionRequest.req.ttl,{id:t,topic:i,params:r}=e;await this.client.pendingRequest.set(t,{id:t,topic:i,params:r}),s&&this.client.core.expirer.set(t,_(s))},this.sendRequest=async(e,s,t,i,r)=>{const o=ke(s,t);if(Ne()&&oe.includes(s)){const h=z(JSON.stringify(o));await this.client.core.verify.register({attestationId:h})}const a=await this.client.core.crypto.encode(e,o),l=O[s].req;return i&&(l.ttl=i),r&&(l.id=r),this.client.core.history.set(e,o),this.client.core.relayer.publish(e,a,l),o.id},this.sendResult=async(e,s,t)=>{const i=ze(e,t),r=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=O[o.request.method].res;this.client.core.relayer.publish(s,r,a),await this.client.core.history.resolve(i)},this.sendError=async(e,s,t)=>{const i=Ye(e,t),r=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=O[o.request.method].res;this.client.core.relayer.publish(s,r,a),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{P(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{P(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:s}=e,{message:t}=c("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(t)},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(w({},s.params));const r=_(u),o=w({id:i,pairingTopic:e,expiry:r},t);await this.setProposal(i,o);const a=z(JSON.stringify(s)),l=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit("session_proposal",{id:i,params:o,verifyContext:l})}catch(r){await this.sendError(i,e,r),this.client.logger.error(r)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(N(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const r=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:r});const o=r.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const l=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const h=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else f(s)&&(await this.client.proposal.delete(t,R("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:l,requiredNamespaces:h,optionalNamespaces:I,sessionProperties:g,pairingTopic:E}=s.params,m=w({topic:e,relay:r,expiry:a,namespaces:l,acknowledged:!0,pairingTopic:E,requiredNamespaces:h,optionalNamespaces:I,controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},g&&{sessionProperties:g});await this.sendResult(s.id,e,!0),this.events.emit(p("session_connect"),{session:m}),this.cleanupDuplicatePairings(m)}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;N(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",t),{})):f(s)&&(await this.client.session.delete(e,R("USER_DISCONNECTED")),this.events.emit(p("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidUpdate(w({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(i,e,!0),this.client.events.emit("session_update",{id:i,topic:e,params:t})}catch(r){await this.sendError(i,e,r),this.client.logger.error(r)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_update",t),{}):f(s)&&this.events.emit(p("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,_(C)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_extend",t),{}):f(s)&&this.events.emit(p("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{N(s)?this.events.emit(p("session_ping",t),{}):f(s)&&this.events.emit(p("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(L.publish,async()=>{i(await this.deleteSession(e))})}),this.sendResult(t,e,!0)]),this.client.events.emit("session_delete",{id:t,topic:e})}catch(i){this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(w({topic:e},i)),await this.setPendingSessionRequest({id:t,topic:e,params:i});const r=z(JSON.stringify(s)),o=this.client.session.get(e),a=await this.getVerifyContext(r,o.peer.metadata);this.client.events.emit("session_request",{id:t,topic:e,params:i,verifyContext:a})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;N(s)?this.events.emit(p("session_request",t),{result:s.result}):f(s)&&this.events.emit(p("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidEmit(w({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i})}catch(r){await this.sendError(t,e,r),this.client.logger.error(r)}},this.isValidConnect=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:r,relays:o}=e;if(x(s)||await this.isValidPairingTopic(s),!fe(o,!0)){const{message:a}=c("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!x(t)&&k(t)!==0&&this.validateNamespaces(t,"requiredNamespaces"),!x(i)&&k(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),x(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(e,s)=>{const t=ve(e,"connect()",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!S(e))throw new Error(c("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i,sessionProperties:r}=e;await this.isValidProposalId(s);const o=this.client.proposal.get(s),a=Y(t,"approve()");if(a)throw new Error(a.message);const l=B(o.requiredNamespaces,t,"approve()");if(l)throw new Error(l.message);if(!D(i,!0)){const{message:h}=c("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}x(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!Pe(t)){const{message:i}=c("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!S(e)){const{message:l}=c("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:s,controller:t,namespaces:i,expiry:r}=e;if(!qe(s)){const{message:l}=c("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=Oe(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=Y(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(P(r)){const{message:l}=c("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),r=Y(t,"update()");if(r)throw new Error(r.message);const o=B(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!S(e)){const{message:a}=c("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:i,expiry:r}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!W(o,i)){const{message:a}=c("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!Ve(t)){const{message:a}=c("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!Te(o,i,t.method)){const{message:a}=c("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(r&&!xe(r,$)){const{message:a}=c("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${$.min} and ${$.max}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!S(e)){const{message:i}=c("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!De(t)){const{message:i}=c("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!S(e)){const{message:o}=c("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:r}=this.client.session.get(s);if(!W(r,i)){const{message:o}=c("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!Ce(t)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!Ae(r,i,t.name)){const{message:o}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!S(e)){const{message:t}=c("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||"",validation:"UNKNOWN",origin:s.url||""}};try{const i=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});i&&(t.verified.origin=i,t.verified.validation=i===s.url?"VALID":"INVALID")}catch(i){this.client.logger.error(i)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!D(t,!1)){const{message:i}=c("MISSING_OR_INVALID",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}})}}isInitialized(){if(!this.initialized){const{message:n}=c("NOT_INITIALIZED",this.name);throw new Error(n)}}registerRelayerEvents(){this.client.core.relayer.on(L.message,async n=>{const{topic:e,message:s}=n;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);je(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):Je(t)?(await this.client.core.history.resolve(t),await this.onRelayEventResponse({topic:e,payload:t}),this.client.core.history.delete(e,t.id)):this.onRelayEventUnknownPayload({topic:e,payload:t})})}registerExpirerEvents(){this.client.core.expirer.on(he.expired,async n=>{const{topic:e,id:s}=Le(n.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,c("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}isValidPairingTopic(n){if(!D(n,!1)){const{message:e}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(e)}if(P(this.client.core.pairing.pairings.get(n).expiry)){const{message:e}=c("EXPIRED",`pairing topic: ${n}`);throw new Error(e)}}async isValidSessionTopic(n){if(!D(n,!1)){const{message:e}=c("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(e)}if(!this.client.session.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(e)}if(P(this.client.session.get(n).expiry)){await this.deleteSession(n);const{message:e}=c("EXPIRED",`session topic: ${n}`);throw new Error(e)}}async isValidSessionOrPairingTopic(n){if(this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(D(n,!1)){const{message:e}=c("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(e)}else{const{message:e}=c("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(e)}}async isValidProposalId(n){if(!be(n)){const{message:e}=c("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(e)}if(!this.client.proposal.keys.includes(n)){const{message:e}=c("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(e)}if(P(this.client.proposal.get(n).expiry)){await this.deleteProposal(n);const{message:e}=c("EXPIRED",`proposal id: ${n}`);throw new Error(e)}}}class rs extends K{constructor(n,e){super(n,e,se,b),this.core=n,this.logger=e}}class os extends K{constructor(n,e){super(n,e,ie,b),this.core=n,this.logger=e}}class as extends K{constructor(n,e){super(n,e,re,b,s=>s.id),this.core=n,this.logger=e}}class M extends Se{constructor(n){super(n),this.protocol=j,this.version=J,this.name=G.name,this.events=new Me,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=n?.name||G.name,this.metadata=n?.metadata||Ge();const e=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:ge(me({level:n?.logger||G.logger}));this.core=n?.core||new de(n),this.logger=ue(e,this.name),this.session=new os(this.core,this.logger),this.proposal=new rs(this.core,this.logger),this.pendingRequest=new as(this.core,this.logger),this.engine=new ns(this)}static async init(n){const e=new M(n);return await e.initialize(),e}get context(){return we(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const cs=M;export{ne as ENGINE_CONTEXT,O as ENGINE_RPC_OPTS,Be as HISTORY_CONTEXT,Fe as HISTORY_EVENTS,We as HISTORY_STORAGE_VERSION,oe as METHODS_TO_VERIFY,se as PROPOSAL_CONTEXT,Qe as PROPOSAL_EXPIRY,te as PROPOSAL_EXPIRY_MESSAGE,re as REQUEST_CONTEXT,ie as SESSION_CONTEXT,C as SESSION_EXPIRY,$ as SESSION_REQUEST_EXPIRY_BOUNDARIES,X as SIGN_CLIENT_CONTEXT,G as SIGN_CLIENT_DEFAULT,Xe as SIGN_CLIENT_EVENTS,j as SIGN_CLIENT_PROTOCOL,He as SIGN_CLIENT_STORAGE_OPTIONS,b as SIGN_CLIENT_STORAGE_PREFIX,J as SIGN_CLIENT_VERSION,cs as SignClient,ee as WALLETCONNECT_DEEPLINK_CHOICE,M as default};
//# sourceMappingURL=index.es.js.map
